# Linuxのしくみ
## 第１章　Linuxの概要
- 動作中のプログラムのことをプロセスと呼ぶ
- カーネル
  - カーネルはプロセスがデバイスに直接アクセスできないようにしている
  - Linuxの場合はカーネルがカーネルモードで動作し、デバイスにアクセスする
  - プロセスはユーザーモードで実行されるので、デバイスに直接アクセスすることはできない
- システムコール
  - プロセスはシステムコールを発行、CPUにおいて例外を発生(CPUのモードがユーザーモードからカーネルモードに移行)させることで、間接的にデバイスにアクセスする
- ライブラリ
  - 多くのプログラムが利用するライブラリはOSが提供することがある
  - LinuxではglibcというC言語の標準ライブラリが提供されている
  - glibc(libc)はシステムコールのラッパー関数も提供している
    - システムコールは高級言語から直接呼び出せず、アーキテクチャ依存のアセンブリコードを使って呼び出す必要がある
    - アーキテクチャによらず高級言語からシステムコールを呼べるようにするために、libcがラッパー関数を提供している
- 静的ライブラリと動的ライブラリ
  - 静的ライブラリはビルド時にプログラムに組み込まれる
  - 動的ライブラリは実行時にそのライブラリのその関数を実際に呼ぶ
  - 動的ライブラリが主流だったが、近年になって静的ライブラリも見直されている（サイズの問題などが小さくなったため)

## 第２章 プロセス管理（基礎編)
- プロセスの生成
  - 同じプロセスを二つに分裂させるfork()
    - 処理の分割
    - 親プロセスがfork()を呼び、子プロセス用のメモリ領域を確保して親プロセスのメモリをコピー
    - 親プロセスと子プロセスがfork()から復帰するが、返り値が異なるので同じプログラムから呼び出しても処理を分岐できる
    - オーバーヘッドは小さい
  - 別のプログラムを起動するexecve()
    - forkしたあとに子プロセスで実行することで実質他のプログラムを起動したことになる
    - execve()で別の実行ファイルに子プロセスの中身が入れ替わることになるので、実行ファイルのメモリマップ開始アドレスやエントリポイント(最初に実行する命令のメモリアドレス)はELFというフォーマットで実行ファイルが保持している(実行ファイルはELFというフォーマットで記述されている)
    - Linuxはデフォルトでプログラムを実行するたびに各セクションを別のアドレスにマップする(ASLR)
- プロセスの親子関係
  - すべてのプロセスの親をたどるとinitプロセスに行き着く
- プロセスの状態
  - S(スリープ)
  - R(実行可能状態)
    - CPUの実行権を持っているときは「実行状態」
  - Z(ゾンビ)
  - システムの全プロセスがスリープ状態の時は、アイドルプロセスという何もしない特殊なプロセスが動いている
- プロセスの終了
  - プロセスが終了した後は、親プロセスがwait()やwaitpid()で次のような値を取得できる
    - プロセスの戻り値(exit()の引数)
    - シグナルによって胃終了したか
    - 終了までにどれだけCPU時間を使ったか
- ゾンビプロセスと孤児プロセス
  - ゾンビプロセス
    - 子の処理が終了したのに、親がwait()などを発行しないのでシステム上に残っているプロセス
  - 孤児プロセス
    - 親がwait()を発行する前に親が終了してしまった子プロセス
    - initが親になり、定期的に発行されるwait()によりリソースが回収される
- シグナル
  - あるプロセスが他のプロセスに送り、強制的に処理の流れを変える仕組み
  - 各プロセスは、それぞれのシグナルに対してどう対応するかというシグナルハンドラを登録しておける
- セッションとプロセスグループ
  - セッション
    - ターミナルのシェルにつき一つのセッション、そこから起動したプロセスは同じセッションに属するジョブとなる
    - シェル(bashなど)が通常セッションリーダーというプロセスになり、そのPIDがセッションIDとなる
    - ターミナルが終了した場合はセッションリーダー(bash)にSIGHUPが送られ、bashは同じセッションに属するジョブを終了させる
    - nohupでSIGHUPを無視する設定でプロセスを起動したり、disownで起動しているプロセスをジョブテーブルから外す（ことにより巻き込まれて終了しない)ようにできる
  - プロセスグループ
    - 複数のプロセスのまとまりで、基本的にシェルが作ったジョブが相当する
    - フォアグラウンドプロセスグループ
      - 端末にアクセスできるプロセスグループ(ジョブ)
    - バックグラウンドプロセスグループ
      - 端末にアクセスできないプロセスグループ(ジョブ)
      - 端末にアクセスしようとすると待機状態となる
- デーモン
 - 常駐プロセス
 - 特徴
  - 端末が割り当てられない
  - 独自のセッションを持つ
  - initが親
- 特徴を満たさなくても常駐していればデーモンと呼ぶことがある
- 端末を持たないので、端末のハングアップを表すSIGHUPが別の用途に使える
  - 設定ファイルを読み直す挙動にするのが慣習
## 第３章 プロセススケジューラ
- 経過時間
  - プロセス開始から終了までの実時間
- 使用時間
  - プロセスが実際にCPUを使用した時間
- レイテンシターゲット(なぜこの訳...)
  - 使用権が一巡りする時間(kernel.sched_latency_ns)
- タイムスライス
  - プロセスが一回に使えるCPU割り当て時間のこと
- コンテキストスイッチ
  - 論理CPU上で動作するプロセスが切り替わること
  - ある処理に時間がかかっている場合、コンテキストスイッチが発生して他のプロセスが動いたのかもしれない
- 複数論理CPU、並列処理時の性能について
  - CPUの数よりプロセス数を多くしても平均ターンアラウンドタイムは長くなり、スループットも向上しない
  - Webサーバーは平均ターンアラウンドタイムが大事なので、スループット重視のシステムよりもCPU使用率を抑えるべき
  - CPUが多いなら十分なプロセスを実行させないと意味がない
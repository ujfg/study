# Linuxのしくみ
## 第１章　Linuxの概要
- 動作中のプログラムのことをプロセスと呼ぶ
- カーネル
  - カーネルはプロセスがデバイスに直接アクセスできないようにしている
  - Linuxの場合はカーネルがカーネルモードで動作し、デバイスにアクセスする
  - プロセスはユーザーモードで実行されるので、デバイスに直接アクセスすることはできない
- システムコール
  - プロセスはシステムコールを発行、CPUにおいて例外を発生(CPUのモードがユーザーモードからカーネルモードに移行)させることで、間接的にデバイスにアクセスする
- ライブラリ
  - 多くのプログラムが利用するライブラリはOSが提供することがある
  - LinuxではglibcというC言語の標準ライブラリが提供されている
  - glibc(libc)はシステムコールのラッパー関数も提供している
    - システムコールは高級言語から直接呼び出せず、アーキテクチャ依存のアセンブリコードを使って呼び出す必要がある
    - アーキテクチャによらず高級言語からシステムコールを呼べるようにするために、libcがラッパー関数を提供している
- 静的ライブラリと動的ライブラリ
  - 静的ライブラリはビルド時にプログラムに組み込まれる
  - 動的ライブラリは実行時にそのライブラリのその関数を実際に呼ぶ
  - 動的ライブラリが主流だったが、近年になって静的ライブラリも見直されている（サイズの問題などが小さくなったため)

## 第２章 プロセス管理（基礎編)
- プロセスの生成
  - 同じプロセスを二つに分裂させるfork()
    - 処理の分割
    - 親プロセスがfork()を呼び、子プロセス用のメモリ領域を確保して親プロセスのメモリをコピー
    - 親プロセスと子プロセスがfork()から復帰するが、返り値が異なるので同じプログラムから呼び出しても処理を分岐できる
    - オーバーヘッドは小さい
  - 別のプログラムを起動するexecve()
    - forkしたあとに子プロセスで実行することで実質他のプログラムを起動したことになる
    - execve()で別の実行ファイルに子プロセスの中身が入れ替わることになるので、実行ファイルのメモリマップ開始アドレスやエントリポイント(最初に実行する命令のメモリアドレス)はELFというフォーマットで実行ファイルが保持している(実行ファイルはELFというフォーマットで記述されている)
    - Linuxはデフォルトでプログラムを実行するたびに各セクションを別のアドレスにマップする(ASLR)
- プロセスの親子関係
  - すべてのプロセスの親をたどるとinitプロセスに行き着く
- プロセスの状態
  - S(スリープ)
  - R(実行可能状態)
    - CPUの実行権を持っているときは「実行状態」
  - Z(ゾンビ)
  - システムの全プロセスがスリープ状態の時は、アイドルプロセスという何もしない特殊なプロセスが動いている
- プロセスの終了
  - プロセスが終了した後は、親プロセスがwait()やwaitpid()で次のような値を取得できる
    - プロセスの戻り値(exit()の引数)
    - シグナルによって胃終了したか
    - 終了までにどれだけCPU時間を使ったか
- ゾンビプロセスと孤児プロセス
  - ゾンビプロセス
    - 子の処理が終了したのに、親がwait()などを発行しないのでシステム上に残っているプロセス
  - 孤児プロセス
    - 親がwait()を発行する前に親が終了してしまった子プロセス
    - initが親になり、定期的に発行されるwait()によりリソースが回収される
- シグナル
  - あるプロセスが他のプロセスに送り、強制的に処理の流れを変える仕組み
  - 各プロセスは、それぞれのシグナルに対してどう対応するかというシグナルハンドラを登録しておける
- セッションとプロセスグループ
  - セッション
    - ターミナルのシェルにつき一つのセッション、そこから起動したプロセスは同じセッションに属するジョブとなる
    - シェル(bashなど)が通常セッションリーダーというプロセスになり、そのPIDがセッションIDとなる
    - ターミナルが終了した場合はセッションリーダー(bash)にSIGHUPが送られ、bashは同じセッションに属するジョブを終了させる
    - nohupでSIGHUPを無視する設定でプロセスを起動したり、disownで起動しているプロセスをジョブテーブルから外す（ことにより巻き込まれて終了しない)ようにできる
  - プロセスグループ
    - 複数のプロセスのまとまりで、基本的にシェルが作ったジョブが相当する
    - フォアグラウンドプロセスグループ
      - 端末にアクセスできるプロセスグループ(ジョブ)
    - バックグラウンドプロセスグループ
      - 端末にアクセスできないプロセスグループ(ジョブ)
      - 端末にアクセスしようとすると待機状態となる
- デーモン
 - 常駐プロセス
 - 特徴
  - 端末が割り当てられない
  - 独自のセッションを持つ
  - initが親
- 特徴を満たさなくても常駐していればデーモンと呼ぶことがある
- 端末を持たないので、端末のハングアップを表すSIGHUPが別の用途に使える
  - 設定ファイルを読み直す挙動にするのが慣習
## 第３章 プロセススケジューラ
- 経過時間
  - プロセス開始から終了までの実時間
- 使用時間
  - プロセスが実際にCPUを使用した時間
- レイテンシターゲット(なぜこの訳...)
  - 使用権が一巡りする時間(kernel.sched_latency_ns)
- タイムスライス
  - プロセスが一回に使えるCPU割り当て時間のこと
- コンテキストスイッチ
  - 論理CPU上で動作するプロセスが切り替わること
  - ある処理に時間がかかっている場合、コンテキストスイッチが発生して他のプロセスが動いたのかもしれない
- 複数論理CPU、並列処理時の性能について
  - CPUの数よりプロセス数を多くしても平均ターンアラウンドタイムは長くなり、スループットも向上しない
  - Webサーバーは平均ターンアラウンドタイムが大事なので、スループット重視のシステムよりもCPU使用率を抑えるべき
  - CPUが多いなら十分なプロセスを実行させないと意味がない
## 第４章 メモリ管理システム
- メモリ関連情報
  - used
    - 使用されているメモリ
    - プロセスが終了するとそのメモリはカーネルにより解放される
  - buff/cache
    - ページキャッシュとバッファキャッシュ
    - メモリ上にファイルのデータをキャッシュしておくカーネルの機能
- メモリの回収処理
 - freeメモリが少なくなると、カーネルのメモリ管理システムは解放可能なメモリ(未変更のページキャッシュなど)を解放する
 - それでも足りない場合はOOM(Out of Memory)状態になり、適当なプロセスが強制終了される(OOM killer)
- 仮想記憶
  - プロセスごとに一定の値(32bitだと4GB、64bitだと16TB)が仮想アドレス空間として割り当てられる
  - プロセスはこの仮想アドレスにアクセスし、カーネルがプロセス生成時にカーネルが作成したページテーブルの変換表に従ってCPUが物理アドレスに変換する
  - ページエントリはあるが物理アドレスは割り当てられていない状態から始まり、ページフォールトした際にページフォールとハンドラにより物理メモリが割り当てられる
  - 不正なアドレスへのアクセスもページフォールとハンドラによって検出され、SIGSEGVが送られる(セグフォ)
  - マルチプロセスを実現し、ページの断片化や不正なアドレスへのアクセスが防げる
  - ページテーブルエントリもリソースを消費する&ほとんどのプロセスは仮想アドレス空間を目一杯使うことはないため、階層構造にしてエントリ数を減らして管理する仕組みがある
  - ヒュージページ（通常より大きいページ)に結合、分解する仕組みもある
## 第５章 プロセス管理（応用編)
- コピーオンライト
 - fork()の高速化
  - 親のメモリごとコピーするのではなく、ページテーブルのみコピーする
  - コピーの際は親子とも全ページの書き込みを無効化する
  - 親子いずれかがページの内容を更新しようとすると、書き込み権限がないのでページフォールとが発生
  - カーネルのページフォールとハンドラ内で別の物理メモリにコピーされ、親の書き込み制限が解除、子は新たなメモリ領域を参照する
- デマンドページング
  - execve()
    - fork()した後に発行して別のプログラムを動かすやつ
    - execve()した直後は物理メモリは割り当てられていない
    - アクセスが発生してページフォールトが発生して初めて物理メモリが割り当てられる
- プロセス間通信
  - 共有メモリ
    - メモリ取得時に共有メモリとして取得することで、別プロセスで同じメモリを参照できる
  - シグナル
    - SIGUSR1やSIGUSR2などプログラマが自由に用途を決めていいシグナルがあるが、データの受け渡しはできないので単純用途向き
  - パイプ
    - `|`で標準出力を繋げられる
  - ソケット
    - UNIXドメインソケット(１つのマシン上のプロセス同士を通信させる)
    - TCPソケット、UDPソケット(別マシンのプロセスと通信できる、インターネットで広く使われる)
- 排他制御とファイルロック
  - クリティカルセクション(同時に実行されると困る処理)をアトミック処理(分割できない処理)にする
  - ファイルロック
    - 高級言語レベルで制御すると大変なので、CPUアーキテクチャで処理をアトミックにする命令が用意されている
- マルチプロセスとマルチスレッド
  - マルチプロセス
    - プロセスをたくさん生成して、あとはプロセス間通信で協働
    - ページテーブルコピーのコスト
    - リソースの消費
    - スレッドセーフにする必要なし
  - マルチスレッド
    - 同一プロセス内で複数の処理の流れを実現
    - ページテーブルコピー不要
    - リソース消費少ない
    - メモリ共有により協働しやすいが、スレッドセーフにするのが難しい
    - goroutineなどで扱いを簡単にしている例もある
  - カーネルスレッドとユーザースレッド
    - カーネルスレッド
      - ロードされるメモリ空間：カーネル空間
      - スケジューリングの管理：OSカーネル
      - 実体：task_struct構造体(固有のメモリ空間を持たないのでmm_structフィールドがNULL)
      - 実行モード：カーネルモード
      - 役割：システムコールの実際の処理やメモリ回収といったクリティカルな処理
    - ユーザースレッド
      - ロードされるメモリ空間：ユーザー空間
      - スケジューリングの管理：ユーザー空間上のプログラム(スレッドライブラリ(第三者が提供するライブラリ)のスレッドスケジューラが行う)
      - 実体：task_struct
      - 実行モード：ユーザーモードとカーネルモードを行き来する
      - 役割：ユーザーが書いたプログラム
## 第６章 デバイスアクセス
- デバイスファイル
  - デバイスを通常ファイルと同様に操作できる
  - プロセスがデバイスファイルを操作すると、カーネルの中のデバイスドライバがデバイスにアクセスする
  - キャラクタデバイス
    - 読み出しと書き込みのみ可
    - ターミナルやマウス、キーボードなど
  - ブロックデバイス
    - 読み書きに加えてシークも可能
    - HDDやSSDなど
- デバイスドライバ
  - カーネル機能
  - デバイスドライバが、デバイスのレジスタと呼ばれる領域にアクセスすることによってデバイスに要求を伝える
  - MMIO(メモリマップトI/O)
    - カーネルの仮想アドレス空間にデバイスのレジスタ領域を読み込む
    - 以下のような領域に書き込むことで、読み書きを行う
      - レジスタ領域には読み書きに使うアドレス
      - ストレージデバイス内のアドレスの指定に使うアドレス
      - 読み書きのサイズの指定に使うアドレス
      - 書き込み要求を開始するアドレス
      - 要求した処理が終わったかどうかを示すフラグを入れるアドレス
  - ポーリング
    - デバイスドライバが能動的にデバイスの処理が完了したかを確認するやり方
    - 要求した処理が終わったかどうかのレジスタを読み出し続ける
    - CPUは他の作業ができなくなるが、後述の割り込みが負荷になる場合はあえてポーリングする場合もある
  - 割り込み
    - デバイスの処理が始まるとCPUは別の作業ができ、終わり次第デバイスドライバが割り込みを通知する
- デバイスファイル名の変化
  - デバイスファイル名は接続される順番等によって変化するので、systemd(initプロセス)が作るpersistent devise nameを利用したり、UUIDをデバイスごとにつけたりして問題を回避する
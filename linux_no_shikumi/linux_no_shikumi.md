# Linuxのしくみ
## 第１章　Linuxの概要
- 動作中のプログラムのことをプロセスと呼ぶ
- カーネル
  - カーネルはプロセスがデバイスに直接アクセスできないようにしている
  - Linuxの場合はカーネルがカーネルモードで動作し、デバイスにアクセスする
  - プロセスはユーザーモードで実行されるので、デバイスに直接アクセスすることはできない
- システムコール
  - プロセスはシステムコールを発行、CPUにおいて例外を発生(CPUのモードがユーザーモードからカーネルモードに移行)させることで、間接的にデバイスにアクセスする
- ライブラリ
  - 多くのプログラムが利用するライブラリはOSが提供することがある
  - LinuxではglibcというC言語の標準ライブラリが提供されている
  - glibc(libc)はシステムコールのラッパー関数も提供している
    - システムコールは高級言語から直接呼び出せず、アーキテクチャ依存のアセンブリコードを使って呼び出す必要がある
    - アーキテクチャによらず高級言語からシステムコールを呼べるようにするために、libcがラッパー関数を提供している
- 静的ライブラリと動的ライブラリ
  - 静的ライブラリはビルド時にプログラムに組み込まれる
  - 動的ライブラリは実行時にそのライブラリのその関数を実際に呼ぶ
  - 動的ライブラリが主流だったが、近年になって静的ライブラリも見直されている（サイズの問題などが小さくなったため)

## 第２章 プロセス管理（基礎編)
- プロセスの生成
  - 同じプロセスを二つに分裂させるfork()
    - 処理の分割
    - 親プロセスがfork()を呼び、子プロセス用のメモリ領域を確保して親プロセスのメモリをコピー
    - 親プロセスと子プロセスがfork()から復帰するが、返り値が異なるので同じプログラムから呼び出しても処理を分岐できる
    - オーバーヘッドは小さい
  - 別のプログラムを起動するexecve()
    - forkしたあとに子プロセスで実行することで実質他のプログラムを起動したことになる
    - execve()で別の実行ファイルに子プロセスの中身が入れ替わることになるので、実行ファイルのメモリマップ開始アドレスやエントリポイント(最初に実行する命令のメモリアドレス)はELFというフォーマットで実行ファイルが保持している(実行ファイルはELFというフォーマットで記述されている)
    - Linuxはデフォルトでプログラムを実行するたびに各セクションを別のアドレスにマップする(ASLR)
- プロセスの親子関係
  - すべてのプロセスの親をたどるとinitプロセスに行き着く
- プロセスの状態
  - S(スリープ)
  - R(実行可能状態)
    - CPUの実行権を持っているときは「実行状態」
  - Z(ゾンビ)
  - システムの全プロセスがスリープ状態の時は、アイドルプロセスという何もしない特殊なプロセスが動いている
- プロセスの終了
  - プロセスが終了した後は、親プロセスがwait()やwaitpid()で次のような値を取得できる
    - プロセスの戻り値(exit()の引数)
    - シグナルによって胃終了したか
    - 終了までにどれだけCPU時間を使ったか
- ゾンビプロセスと孤児プロセス
  - ゾンビプロセス
    - 子の処理が終了したのに、親がwait()などを発行しないのでシステム上に残っているプロセス
  - 孤児プロセス
    - 親がwait()を発行する前に親が終了してしまった子プロセス
    - initが親になり、定期的に発行されるwait()によりリソースが回収される
- シグナル
  - あるプロセスが他のプロセスに送り、強制的に処理の流れを変える仕組み
  - 各プロセスは、それぞれのシグナルに対してどう対応するかというシグナルハンドラを登録しておける
- セッションとプロセスグループ
  - セッション
    - ターミナルのシェルにつき一つのセッション、そこから起動したプロセスは同じセッションに属するジョブとなる
    - シェル(bashなど)が通常セッションリーダーというプロセスになり、そのPIDがセッションIDとなる
    - ターミナルが終了した場合はセッションリーダー(bash)にSIGHUPが送られ、bashは同じセッションに属するジョブを終了させる
    - nohupでSIGHUPを無視する設定でプロセスを起動したり、disownで起動しているプロセスをジョブテーブルから外す（ことにより巻き込まれて終了しない)ようにできる
  - プロセスグループ
    - 複数のプロセスのまとまりで、基本的にシェルが作ったジョブが相当する
    - フォアグラウンドプロセスグループ
      - 端末にアクセスできるプロセスグループ(ジョブ)
    - バックグラウンドプロセスグループ
      - 端末にアクセスできないプロセスグループ(ジョブ)
      - 端末にアクセスしようとすると待機状態となる
- デーモン
 - 常駐プロセス
 - 特徴
  - 端末が割り当てられない
  - 独自のセッションを持つ
  - initが親
- 特徴を満たさなくても常駐していればデーモンと呼ぶことがある
- 端末を持たないので、端末のハングアップを表すSIGHUPが別の用途に使える
  - 設定ファイルを読み直す挙動にするのが慣習
## 第３章 プロセススケジューラ
- 経過時間
  - プロセス開始から終了までの実時間
- 使用時間
  - プロセスが実際にCPUを使用した時間
- レイテンシターゲット(なぜこの訳...)
  - 使用権が一巡りする時間(kernel.sched_latency_ns)
- タイムスライス
  - プロセスが一回に使えるCPU割り当て時間のこと
- コンテキストスイッチ
  - 論理CPU上で動作するプロセスが切り替わること
  - ある処理に時間がかかっている場合、コンテキストスイッチが発生して他のプロセスが動いたのかもしれない
- 複数論理CPU、並列処理時の性能について
  - CPUの数よりプロセス数を多くしても平均ターンアラウンドタイムは長くなり、スループットも向上しない
  - Webサーバーは平均ターンアラウンドタイムが大事なので、スループット重視のシステムよりもCPU使用率を抑えるべき
  - CPUが多いなら十分なプロセスを実行させないと意味がない
## 第４章 メモリ管理システム
- メモリ関連情報
  - used
    - 使用されているメモリ
    - プロセスが終了するとそのメモリはカーネルにより解放される
  - buff/cache
    - ページキャッシュとバッファキャッシュ
    - メモリ上にファイルのデータをキャッシュしておくカーネルの機能
- メモリの回収処理
 - freeメモリが少なくなると、カーネルのメモリ管理システムは解放可能なメモリ(未変更のページキャッシュなど)を解放する
 - それでも足りない場合はOOM(Out of Memory)状態になり、適当なプロセスが強制終了される(OOM killer)
- 仮想記憶
  - プロセスごとに一定の値(32bitだと4GB、64bitだと16TB)が仮想アドレス空間として割り当てられる
  - プロセスはこの仮想アドレスにアクセスし、カーネルがプロセス生成時にカーネルが作成したページテーブルの変換表に従ってCPUが物理アドレスに変換する
  - ページエントリはあるが物理アドレスは割り当てられていない状態から始まり、ページフォールトした際にページフォールとハンドラにより物理メモリが割り当てられる
  - 不正なアドレスへのアクセスもページフォールとハンドラによって検出され、SIGSEGVが送られる(セグフォ)
  - マルチプロセスを実現し、ページの断片化や不正なアドレスへのアクセスが防げる
  - ページテーブルエントリもリソースを消費する&ほとんどのプロセスは仮想アドレス空間を目一杯使うことはないため、階層構造にしてエントリ数を減らして管理する仕組みがある
  - ヒュージページ（通常より大きいページ)に結合、分解する仕組みもある
## 第５章 プロセス管理（応用編)
- コピーオンライト
 - fork()の高速化
  - 親のメモリごとコピーするのではなく、ページテーブルのみコピーする
  - コピーの際は親子とも全ページの書き込みを無効化する
  - 親子いずれかがページの内容を更新しようとすると、書き込み権限がないのでページフォールとが発生
  - カーネルのページフォールとハンドラ内で別の物理メモリにコピーされ、親の書き込み制限が解除、子は新たなメモリ領域を参照する
- デマンドページング
  - execve()
    - fork()した後に発行して別のプログラムを動かすやつ
    - execve()した直後は物理メモリは割り当てられていない
    - アクセスが発生してページフォールトが発生して初めて物理メモリが割り当てられる
- プロセス間通信
  - 共有メモリ
    - メモリ取得時に共有メモリとして取得することで、別プロセスで同じメモリを参照できる
  - シグナル
    - SIGUSR1やSIGUSR2などプログラマが自由に用途を決めていいシグナルがあるが、データの受け渡しはできないので単純用途向き
  - パイプ
    - `|`で標準出力を繋げられる
  - ソケット
    - UNIXドメインソケット(１つのマシン上のプロセス同士を通信させる)
    - TCPソケット、UDPソケット(別マシンのプロセスと通信できる、インターネットで広く使われる)
- 排他制御とファイルロック
  - クリティカルセクション(同時に実行されると困る処理)をアトミック処理(分割できない処理)にする
  - ファイルロック
    - 高級言語レベルで制御すると大変なので、CPUアーキテクチャで処理をアトミックにする命令が用意されている
- マルチプロセスとマルチスレッド
  - マルチプロセス
    - プロセスをたくさん生成して、あとはプロセス間通信で協働
    - ページテーブルコピーのコスト
    - リソースの消費
    - スレッドセーフにする必要なし
  - マルチスレッド
    - 同一プロセス内で複数の処理の流れを実現
    - ページテーブルコピー不要
    - リソース消費少ない
    - メモリ共有により協働しやすいが、スレッドセーフにするのが難しい
    - goroutineなどで扱いを簡単にしている例もある
  - カーネルスレッドとユーザースレッド
    - カーネルスレッド
      - ロードされるメモリ空間：カーネル空間
      - スケジューリングの管理：OSカーネル
      - 実体：task_struct構造体(固有のメモリ空間を持たないのでmm_structフィールドがNULL)
      - 実行モード：カーネルモード
      - 役割：システムコールの実際の処理やメモリ回収といったクリティカルな処理
    - ユーザースレッド
      - ロードされるメモリ空間：ユーザー空間
      - スケジューリングの管理：ユーザー空間上のプログラム(スレッドライブラリ(第三者が提供するライブラリ)のスレッドスケジューラが行う)
      - 実体：task_struct
      - 実行モード：ユーザーモードとカーネルモードを行き来する
      - 役割：ユーザーが書いたプログラム
## 第６章 デバイスアクセス
- デバイスファイル
  - デバイスを通常ファイルと同様に操作できる
  - プロセスがデバイスファイルを操作すると、カーネルの中のデバイスドライバがデバイスにアクセスする
  - キャラクタデバイス
    - 読み出しと書き込みのみ可
    - ターミナルやマウス、キーボードなど
  - ブロックデバイス
    - 読み書きに加えてシークも可能
    - HDDやSSDなど
- デバイスドライバ
  - カーネル機能
  - デバイスドライバが、デバイスのレジスタと呼ばれる領域にアクセスすることによってデバイスに要求を伝える
  - MMIO(メモリマップトI/O)
    - カーネルの仮想アドレス空間にデバイスのレジスタ領域を読み込む
    - 以下のような領域に書き込むことで、読み書きを行う
      - レジスタ領域には読み書きに使うアドレス
      - ストレージデバイス内のアドレスの指定に使うアドレス
      - 読み書きのサイズの指定に使うアドレス
      - 書き込み要求を開始するアドレス
      - 要求した処理が終わったかどうかを示すフラグを入れるアドレス
  - ポーリング
    - デバイスドライバが能動的にデバイスの処理が完了したかを確認するやり方
    - 要求した処理が終わったかどうかのレジスタを読み出し続ける
    - CPUは他の作業ができなくなるが、後述の割り込みが負荷になる場合はあえてポーリングする場合もある
  - 割り込み
    - デバイスの処理が始まるとCPUは別の作業ができ、終わり次第デバイスドライバが割り込みを通知する
- デバイスファイル名の変化
  - デバイスファイル名は接続される順番等によって変化するので、systemd(initプロセス)が作るpersistent devise nameを利用したり、UUIDをデバイスごとにつけたりして問題を回避する
## 第７章 ファイルシステム
- ファイルシステム
  - ストレージデバイス上の位置やサイズなどを意識せずユーザーが使えるようにしてくれる仕組み
  - データのまとまりをファイルという単位で管理する
  - VFS(仮想ファイルシステム)がデバイスごとのファイルシステムの操作に対して統一的なインターフェースを提供しているので、どのようなファイルに対しても同じ関数によってアクセスできる(そしてLinuxでは全てがファイル)
- メモリマップトファイル
  - 仮想アドレス上にファイルの内容をマップする機能
  - メモリと同様にアクセスできるようになるので早い
  - 内容を変更した場合は所定のタイミングでストレージデバイスに書き戻す
- 一般的なファイルシステム
  - ext4 XFS Btrfsなど
  - ファイルの最大サイズやスナップショット機能の有無などに違いがある
- ファイルシステムの整合性保持
  - ジャーナリング
    - ジャーナル領域(ログファイル的なもの)に処理を書き出してから処理を実行、ジャーナル領域を破棄して完了
    - 処理中に電源が落ちた場合などはジャーナル領域の内容を再度実行する
  - コピーオンライト
    - Btrfsなどのスナップショットが撮れるファイルシステムは、ファイルが更新されたら上書きではなく別領域に書き出してリンクを貼り替える
    - 別領域に書き出している最中の強制終了には、作りかけのファイルを削除することによって整合性を保つ
- Btrfsの高度な機能
  - スナップショット
    - メタデータのコピーだけで済むのでコストが低い(更新時にコピーオンライトが働くため)
    - バックアップにはならない(データを共有している場合があるため)
    - バックアップ中にファいうシステム全体のI/Oを止める必要がない(スナップショットだけ撮って、スナップショットのバックアップを取れば良い)
  - データ破壊の検知と修復
    - 全データについてチェックサムを持つので、破損データの検知が可能
    - RAID構成を組んでいれば修復も可能
- その他のファイルシステム
  - メモリベースのファイルシステム
    - tmpfs
    - 高速だが電源オフで消滅。tmpファイルなんかに使う
  - ネットワークファイルシステム
    - NFS(Network File System)やCIFS(Common Internet File System)
    - ネットワーク越しのストレージ領域をローカルにマウントしたりできる
  - procfs
    - プロセスについての情報をファイルシステムとして提供
    - 擬似ファイルシステムなのでディスクスペースは消費しない(メモリから情報を取得)
  - sysfs
    - デバイスやドライバについての情報を擬似ファイルシステムとして提供
## 第８章 記憶階層
- レジスタ、キャッシュメモリ、メモリ、ストレージデバイスの順で速度は遅くなり、容量は多くなる
- キャッシュメモリ
  - CPUはメモリからレジスタにデータを読み出し、計算し、書き戻している
  - 計算速度よりI/Oの方が遅いので、メモリよりCPUに近く(通常CPU内)に存在する高速なキャッシュメモリから読み出そうとする
  - メモリからキャッシュラインという単位でキャッシュメモリにデータを読み出し、それをレジスタに読み出す
  - メモリに書き戻す際は、まずキャッシュメモリに書き戻してダーティであるという印をつける
  - 適切なタイミングでメモリに変更を反映する
    - ライトスルー: 変更のたびにメモリに反映。実装しやすが低速
    - ライトバック: 所定のタイミングでメモリに反映する
      - 五秒に一回など定期的に
      - ダーティーページが増えてきた時に
  - キャッシュメモリとメモリのスワッピングが多発するとスラッシングという状態になり、性能が劣化する
  - キャッシュは割とヒットする
    - 時間的局所性：ループ処理のコードなど、連続した時間で同じメモリにアクセスされやすい
    - 空間的局所性：配列の全要素走査など、ある時点でアクセスしたデータに近いデータがアクセスされやすい
  - 階層型キャッシュメモリ
    - キャッシュメモリの中でも階層化が行われている場合がある(L1キャッシュ、L2キャッシュなど)
- SMT(Simultaneous Multi Threading)
  - CPU使用時間のうち多くはI/O待ちだったり、進行中の演算に関係ないユニットが空いていたりする
  - このような資源を有効活用するため、CPUのレジスタなど一部資源を複数作って、それぞれをスレッドとする
  - Linuxカーネルからは各スレッドを論理CPUとして認識する
- TLB(Translation Lookaside Buffer)
  - 仮想アドレスから物理アドレスへの変換はページテーブルを参照する必要があり、これはメモリ上にある
  - メモリアクセスは低速なので、CPUの中にTLBという領域があり、仮想アドレスから物理アドレスへの変換表を保存する
  - キャッシュメモリとメモリのような関係
- ページキャッシュ
  - ファイルのデータをメモリにキャッシュする仕組み
- バッファキャッシュ
  - ファイルデータ以外のディスク上のデータをキャッシュする仕組み
    - ファイルシステムを使わない、デバイスファイルを用いたストレージデバイスへの直接アクセス時
    - ファイルのメタデータにアクセス時
- direct I/O
  - キャッシュを使わないアクセス
    - 一度読み書きしたら二度と使わないデータへのアクセス
    - プロセスが自分でページキャッシュ相当の仕組みを実装したい場合
- スワップ
  - ストレージデバイスの一部を一時的にメモリとして使用(使用される領域がスワップ領域)
    - ページアウト：スワップ領域への退避
    - ページイン：スワップ領域からの書き戻し
    - メジャーフォールト：スワップの発生するページフォールト
    - マイナーフォールト：スワップの発生しないページフォールト(コピーオンライト時など)
  - スワップが多発するとスラッシングになる
  - 統計情報のkbswpusedフィールド(スワップ領域の使用量)の推移に注意
## 第９章 ブロック層
- ブロック層
  - ブロックデバイスの性能を引き出すための処理を共通化した、ファイルシステムやデバイスファイルとデバイスドライバの中間層
- HDDの特徴
  - プラッタやスイングアームの移動といった機械的処理が大半を占めている
  - こうした処理をできるだけ減らすためにブロック層が後述の仕組みを実装している
- ブロック層の基本機能
  - I/Oスケジューラ
    - I/Oのリクエストを一定数貯め、マージやソートを行ってから実際にデータを取得する
      - マージ：複数の連続するセクタへのI/O要求を一つにまとめる
      - ソート：複数の不連続なセクタへのI/O要求をセクタ番号順に並べる
  - readahead
    - ブロック内のある領域を読み出す時に、後続領域を先読みしておいてページキャッシュに保存しておく仕組み
- ブロックデバイスの性能指標と測定方法
  - スループット
    - 時間あたりのデータの転送量(並列処理の場合、全ての合計)
    - 大きなデータのやり取りで気にする
  - レイテンシ
    - １回あたりのI/Oに要する時間(並列処理しないと長くなる傾向)
    - 細かなデータの頻繁なやり取りで気にする
  - IOPS(I/O per second)
    - 1秒間に処理できるI/Oの数
    - 並列処理できるとプロセス側に処理が写っている間に他のプロセスのI/Oを処理できるため、この数値の高さが効いてくる
- SSDの登場
  - 機械的処理が不要
    - readaheadの効果はかなり高い
    - I/Oスケジューラはない方が高速になる場合もある
## 第１０章 仮想化機能
- 仮想化機能とは
  - 物理マシン上で仮想マシンを動かすためのソフトウェア機能、およびそれを助けるハードウェア機能
- 仮想化ソフトウェア
  - 仮想マシンを生成、管理、破棄するソフトウェア
  - 物理マシンのリソースを各仮想マシンに割り当てる
    - PCPU(Physical CPU)、VCPU(Virtual CPU)
  - 一つの物理マシンに複数の仮想マシンをインストールし、その仮想マシーンそれぞれにカーネルがある
- 仮想化を支援するCPUの機能
  - カーネルのユーザーモードとカーネルモードの考え方を拡張
  - VMX root(物理マシン側)とVMX non-root(仮想マシン側)というモードがあり、それぞれにユーザーモードとカーネルモードがある
  - 仮想マシン側でハードウェアへのアクセスや物理マシンへの割り込みが発生すると上記のモードを行き来する
- 仮想化環境のプロセススケジューリング
  - 物理マシン側の処理と仮想マシン側の処理が順番に行われる場合、仮想マシン側で並行処理していても、物理側マシン側から見ると１つのプロセスなのでCPU使用権が回ってくるまで時間がかかることがある
- 仮想マシンとメモリ管理
  - 仮想マシンを起動すると以下の四箇所のメモリが消費される
    - 物理マシン用カーネルのメモリに仮想マシン管理用メモリが増える
    - 物理マシンのユーザーランド用空きメモリに仮想マシン用メモリが確保される
      - 仮想マシンのカーネル用メモリ
      - 仮想マシンのユーザーランドメモリ
    - 物理マシン側のページキャッシュ用メモリに、仮想マシン起動時に読み出したディスクイメージ領域が増える
- 仮想マシンとストレージデバイス
  - 仮想マシン上のストレージデバイスは、物理デバイス上のファイル、もしくはストレージデバイスと関連づけられている
  - ファイルと関連づけられている場合
    - 仮想マシンと物理マシンのファイルシステム、デバイスドライバ、ストレージデバイス(仮想、物理)、KVMなどを複数回経由するので性能がかなり落ちる(ページキャッシュを使わない場合)
    - ページキャッシュを使うと仮想マシン上でのファイル変更が(オプションで指定しない限り)物理マシン上のファイルに即反映されない
    - 物理マシン上の普通のファイルシステムとも干渉する
  - ストレージデバイスと関連づけられている場合
    - 物理マシンのファイルシステムに干渉しないので影響が少ない
- 仮想マシンのI/O性能を改善する仕組み
  - 準仮想化デバイス
    - 完全仮想化デバイスが物理マシンと全く同じように仮想マシン上でハードウェアをエミュレーションするのではなく、仮想化ソフトウェアと仮想マシンを専用のインターフェースで接続することによってI/O性能の改善を図る
    - virtio-bulk
      - ホストOSとゲストOSが共有するキューを利用し、デバイスアクセスのためのコマンドをまとめて実行することで、モード(VMX-nonroot VMX-root)の切り替え回数を少なくする
  - PCIパススルー
    - 物理デバイスを直接仮想マシンに見せるしくみ
## 第１１章 コンテナ
- 仮想マシンとの違い
  - 仮想マシンは専用の仮想的ハードウェアとカーネルを使う
  - コンテナはホストOSと１つのカーネルを共有する
    - 起動が早い
- コンテナの種類
  - システムコンテナ
    - initプロセスを起動してinitが各種サービスを起動
  - アプリケーションコンテナ
    - コンテナ上で一つのアプリケーションのみを動かす
- namespace
  - 様々なリソースについて、プロセスに対しては独立したリソースのように見える
    - pid namespace(pid ns)
    - user namespace(user ns)
    - mountnamespase(mount ns)
- pid ns
  - あるpid nsを親として、あらたなpid nsを作成できる
  - pid nsごとにpidテーブルが生成される
  - 子pid nsに属するプロセスからは親pid nsのプロセスが見えない(子pid nsのpidテーブルに記載がない)
  - 子pid nsに属するプロセスは他の子pid nsのプロセスが見えない
  - 実質的にはプロセスの実行環境を隔離できている
- コンテナの正体
  - namespace機能を利用して何らかのリソースを分離し、実行環境を分けた１つないし複数のプロセス群のこと
- セキュリティリスク
  - カーネルを共有しているので、カーネルに脆弱性があった場合、分離しているはずの他のns(≒コンテナ)の情報が盗み見られるリスク
## 第１２章 cgroup
- cgroupとは
  - システムのメモリやCPUなどの分配を細かく制御するための機能
  - あるプロセスが他のプロセスを圧迫しないようにしたい場合に使う(Iaasでシステムを複数ユーザーで共有している場合など)
- cgroupで制御できるリソース
  - リソースごとにコントローラというカーネル内プログラムが存在
    - cpuコントローラ
    - memoryコントローラ
    - blkioコントローラ
    - ネットワークコントローラ
- ユースケース
  - systemdでサービスごと、ユーザーごとに自動でグループを作ってリソース管理
  - DockerやKubernetesでコンテナごとのリソース管理
  - libvirtで仮想マシンのリソース管理
# Linuxのしくみ
## 第１章　Linuxの概要
- 動作中のプログラムのことをプロセスと呼ぶ
- カーネル
  - カーネルはプロセスがデバイスに直接アクセスできないようにしている
  - Linuxの場合はカーネルがカーネルモードで動作し、デバイスにアクセスする
  - プロセスはユーザーモードで実行されるので、デバイスに直接アクセスすることはできない
- システムコール
  - プロセスはシステムコールを発行、CPUにおいて例外を発生(CPUのモードがユーザーモードからカーネルモードに移行)させることで、間接的にデバイスにアクセスする
- ライブラリ
  - 多くのプログラムが利用するライブラリはOSが提供することがある
  - LinuxではglibcというC言語の標準ライブラリが提供されている
  - glibc(libc)はシステムコールのラッパー関数も提供している
    - システムコールは高級言語から直接呼び出せず、アーキテクチャ依存のアセンブリコードを使って呼び出す必要がある
    - アーキテクチャによらず高級言語からシステムコールを呼べるようにするために、libcがラッパー関数を提供している
- 静的ライブラリと動的ライブラリ
  - 静的ライブラリはビルド時にプログラムに組み込まれる
  - 動的ライブラリは実行時にそのライブラリのその関数を実際に呼ぶ
  - 動的ライブラリが主流だったが、近年になって静的ライブラリも見直されている（サイズの問題などが小さくなったため)

## 第２章 プロセス管理（基礎編)
- プロセスの生成
  - 同じプロセスを二つに分裂させるfork()
    - 処理の分割
    - 親プロセスがfork()を呼び、子プロセス用のメモリ領域を確保して親プロセスのメモリをコピー
    - 親プロセスと子プロセスがfork()から復帰するが、返り値が異なるので同じプログラムから呼び出しても処理を分岐できる
    - オーバーヘッドは小さい
  - 別のプログラムを起動するexecve()
    - forkしたあとに子プロセスで実行することで実質他のプログラムを起動したことになる
    - execve()で別の実行ファイルに子プロセスの中身が入れ替わることになるので、実行ファイルのメモリマップ開始アドレスやエントリポイント(最初に実行する命令のメモリアドレス)はELFというフォーマットで実行ファイルが保持している(実行ファイルはELFというフォーマットで記述されている)
    - Linuxはデフォルトでプログラムを実行するたびに各セクションを別のアドレスにマップする(ASLR)
- プロセスの親子関係
  - すべてのプロセスの親をたどるとinitプロセスに行き着く
- プロセスの状態
  - S(スリープ)
  - R(実行可能状態)
    - CPUの実行権を持っているときは「実行状態」
  - Z(ゾンビ)
  - システムの全プロセスがスリープ状態の時は、アイドルプロセスという何もしない特殊なプロセスが動いている
- プロセスの終了
  - プロセスが終了した後は、親プロセスがwait()やwaitpid()で次のような値を取得できる
    - プロセスの戻り値(exit()の引数)
    - シグナルによって胃終了したか
    - 終了までにどれだけCPU時間を使ったか